grammar minipy3;

// Parser Rules
PROGRAM: (STATEMENT NEWLINE | NEWLINE)* EOF;
STATEMENT: SIMPLE_STMT | COMPOUND_STMT;
SIMPLE_STMT: ASSIGNMENT_STMT | RETURN_STMT;
COMPOUND_STMT: IF_STMT | WHILE_STMT | FOR_STMT | FUNCDEF;
ASSIGNMENT_STMT: IDENTIFIER ASSIGN EXPRESSION | ARRAY_MEMBER ASSIGN EXPRESSION;
RETURN_STMT: RETURN EXPRESSION?;
IF_STMT: IF CONDITION COLON NEWLINE PROGRAM (ELIF_STMT | ELSE_STMT)?;
ELIF_STMT: ELIF CONDITION COLON NEWLINE PROGRAM (ELIF_STMT | ELSE_STMT)?;
ELSE_STMT: ELSE COLON NEWLINE PROGRAM;
WHILE_STMT: WHILE CONDITION COLON NEWLINE PROGRAM;
FOR_STMT: FOR IDENTIFIER IN EXPRESSION COLON NEWLINE PROGRAM;
FUNCDEF: DEF IDENTIFIER LPAREN PARAMETERS? RPAREN COLON NEWLINE PROGRAM;
PARAMETERS: IDENTIFIER (COMMA IDENTIFIER)*;

CONDITION: LOGIC_EXPR;
LOGIC_EXPR: COMPARISON (LOGIC_OP COMPARISON)*;
COMPARISON: NOT COMPARISON | ALGEBRAIC_EXPR (CONDITIONOP ALGEBRAIC_EXPR)?;
LOGIC_OP: AND | OR;
EXPRESSION: ALGEBRAIC_EXPR | STRING_LITERAL | LIST;
ALGEBRAIC_EXPR: TERM TERMTAIL
TERMTAIL: PLUS TERM TERMTAIL | MINUS TERM TERMTAIL | ε
TERM: FACTOR FACTORTAIL
FACTORTAIL: MULTIPLY FACTOR FACTORTAIL | DIVIDE FACTOR FACTORTAIL | ε
FACTOR: IDENTIFIER | NUMBER | LPAREN ALGEBRAIC_EXPR RPAREN | FUNC_CALL | ARRAY_MEMBER
FUNC_CALL: IDENTIFIER LPAREN (EXPRESSION (COMMA EXPRESSION)*)? RPAREN;
LIST: LBRACKET (EXPRESSION (COMMA EXPRESSION)*)? RBRACKET;

// Lexer Rules
RETURN: 'return';
IF: 'if';
ELIF: 'elif';
ELSE: 'else';
WHILE: 'while';
FOR: 'for';
IN: 'in';
DEF: 'def';
AND: 'and';
OR: 'or';
NOT: 'not';
EQUAL: '=';
COLON: ':';
COMMA: ',';
PLUS: '+';
MINUS: '-';
MULTIPLY: '*';
DIVIDE: '//';
LPAREN: '(';
RPAREN: ')';
LBRACKET: '[';
RBRACKET: ']';
NEWLINE: '\r'? '\n' INDENT?;
INDENT: ('\t')+;
WS: [ \t]+ -> skip;

CONDITIONOP: '==' | '!=' | '>' | '<' | '>=' | '<=';
IDENTIFIER: [a-zA-Z_][a-zA-Z0-9_]*;
NUMBER: '-'? [0-9]+ ('.' [0-9]+)?;
STRING_LITERAL: 
    ('"' (~["\r\n] | '""')* '"') 
    | 
    ('\'' (~['\r\n] | '\'\'')* '\'');