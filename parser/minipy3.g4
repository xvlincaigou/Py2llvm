grammar minipy3;

// Parser Rules
PROGRAM: (STATEMENT NEWLINE | NEWLINE)* EOF;
STATEMENT: SIMPLE_STMT | COMPOUND_STMT;
SIMPLE_STMT: ASSIGNMENT_STMT | RETURN_STMT | EXPR_STMT;
COMPOUND_STMT: IF_STMT | WHILE_STMT | FOR_STMT | FUNCDEF;
ASSIGNMENT_STMT: IDENTIFIER ASSIGN EXPRESSION;
RETURN_STMT: RETURN EXPRESSION?;
EXPR_STMT: EXPRESSION;
IF_STMT: IF CONDITION COLON NEWLINE PROGRAM (ELIF_STMT | ELSE_STMT)?;
ELIF_STMT: ELIF CONDITION COLON NEWLINE PROGRAM (ELIF_STMT | ELSE_STMT)?;
ELSE_STMT: ELSE COLON NEWLINE PROGRAM;
WHILE_STMT: WHILE CONDITION COLON NEWLINE PROGRAM;
FOR_STMT: FOR IDENTIFIER IN EXPRESSION COLON NEWLINE PROGRAM;
FUNCDEF: DEF IDENTIFIER LPAREN PARAMETERS? RPAREN COLON NEWLINE PROGRAM;
PARAMETERS: IDENTIFIER (COMMA IDENTIFIER)*;

EXPRESSION: LOGIC_EXPR;
LOGIC_EXPR: COMPARISON (LOGIC_OP COMPARISON)*;
COMPARISON: NOT COMPARISON | ARITHMETIC_EXPR (CONDITIONOP ARITHMETIC_EXPR)?;
ARITHMETIC_EXPR: TERM ((PLUS | MINUS) TERM)*;
TERM: FACTOR ((MULTIPLY | DIVIDE) FACTOR)*;
FACTOR: IDENTIFIER | NUMBER | STRING_LITERAL | LPAREN EXPRESSION RPAREN | FUNC_CALL | LIST;
FUNC_CALL: IDENTIFIER LPAREN (EXPRESSION (COMMA EXPRESSION)*)? RPAREN;
LIST: LBRACKET (EXPRESSION (COMMA EXPRESSION)*)? RBRACKET;
CONDITION: LOGIC_EXPR;
LOGIC_OP: AND | OR;

// Lexer Rules
RETURN: 'return';
IF: 'if';
ELIF: 'elif';
ELSE: 'else';
WHILE: 'while';
FOR: 'for';
IN: 'in';
DEF: 'def';
AND: 'and';
OR: 'or';
NOT: 'not';
EQUAL: '=';
COLON: ':';
COMMA: ',';
PLUS: '+';
MINUS: '-';
MULTIPLY: '*';
DIVIDE: '//';
LPAREN: '(';
RPAREN: ')';
LBRACKET: '[';
RBRACKET: ']';
NEWLINE: '\r'? '\n' INDENT?;
INDENT: ('\t')+;
WS: [ \t]+ -> skip;

CONDITIONOP: '==' | '!=' | '>' | '<' | '>=' | '<=';
IDENTIFIER: [a-zA-Z_][a-zA-Z0-9_]*;
NUMBER: '-'? [0-9]+ ('.' [0-9]+)?;
STRING_LITERAL: '"' (~["\r\n] | '""')* '"';